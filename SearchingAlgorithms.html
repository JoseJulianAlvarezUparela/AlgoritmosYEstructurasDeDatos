<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link rel="stylesheet" href="css/Styles.css">
    <title>Document</title>
</head>
<body>

    <main>

    <h1>Algoritmos de Busqueda</h1>

    <p>
      Un algoritmo de búsqueda es un conjunto de instrucciones que están diseñadas para localizar un elemento con ciertas propiedades dentro de una estructura de datos. Por ejemplo, un algoritmo de búsqueda podría utilizarse para encontrar un registro correspondiente a cierta persona en una base de datos, o el mejor movimiento en una partida de ajedrez.
    </p>

    <h2>Tipos de algoritmos de busqueda</h2>

    <ul>
        <li>Búsqueda lineal</li>

        <p>
          Un algoritmo de búsqueda lineal es un algoritmo que busca un elemento en una estructura de datos secuencial, comparando cada elemento de la estructura con el elemento buscado.
      </p>
      
      <p>
          Una analogía sencilla para entender el concepto de búsqueda lineal es la siguiente: imagínate que tienes una lista de números ordenados, como [1, 2, 3, 4, 5]. Si quieres encontrar el número 3, puedes empezar por el primer elemento de la lista y compararlo con el número buscado. Si son iguales, has encontrado el elemento. Si no son iguales, comparas el siguiente elemento de la lista, y así sucesivamente. Si llegas al final de la lista sin haber encontrado el elemento buscado, significa que el elemento no está presente en la lista.
      </p>
      
      <img src="assets/Busqueda Lineal.png">

      <p>La búsqueda lineal es un algoritmo de búsqueda simple y fácil de implementar. Funciona comparando cada elemento de una estructura de datos secuencial con el elemento buscado. Si el elemento buscado se encuentra en la estructura, el algoritmo devuelve la posición del elemento en la estructura. Si el elemento buscado no se encuentra en la estructura, el algoritmo devuelve un valor especial, como None o -1.</p>

      <p>La complejidad temporal de la búsqueda lineal es O(n), donde n es el tamaño de la estructura de datos. Esto significa que el tiempo de ejecución del algoritmo es proporcional al tamaño de la estructura de datos.</p>
  
      <p>La búsqueda lineal es un algoritmo eficiente para estructuras de datos pequeñas. Sin embargo, para estructuras de datos grandes, la búsqueda lineal puede ser ineficiente. En estos casos, es preferible utilizar algoritmos de búsqueda más eficientes, como la búsqueda binaria.</p>
  

        <li><strong>Búsqueda lineal centinela</strong></li>

        <p>La búsqueda lineal centinela es una variante de la búsqueda lineal que añade un elemento especial al final de la estructura de datos que se está buscando. Este elemento especial, llamado centinela, tiene un valor mayor que cualquier otro elemento de la estructura de datos.</p>

        <p>La búsqueda lineal centinela funciona de la siguiente manera:</p>

        <img src="assets/BusquedaLinealCentinela.png">

        <ul>
            <li>El algoritmo comienza comparando el elemento actual con el elemento centinela. Si el elemento actual es igual al centinela, el algoritmo devuelve -1, lo que indica que el elemento buscado no se encuentra en la estructura de datos.</li>
            <li>Si el elemento actual no es igual al centinela, el algoritmo compara el elemento actual con el elemento buscado. Si los elementos coinciden, el algoritmo devuelve la posición del elemento actual en la estructura de datos.</li>
            <li>Si los elementos no coinciden, el algoritmo avanza al siguiente elemento de la estructura de datos.</li>
        </ul>

        <p>La búsqueda lineal centinela tiene las siguientes ventajas sobre la búsqueda lineal:</p>

        <ul>
            <li>Garantiza que el algoritmo siempre terminará, incluso si el elemento buscado no se encuentra en la estructura de datos. Esto se debe a que el algoritmo siempre compara el elemento actual con el centinela, y el centinela tiene un valor mayor que cualquier otro elemento de la estructura de datos.</li>
            <li>Reduce la cantidad de comparaciones necesarias en algunos casos. Esto se debe a que el algoritmo puede terminar la búsqueda antes de llegar al final de la estructura de datos si encuentra un elemento que es mayor o igual que el elemento buscado.</li>
        </ul>

        <p>La búsqueda lineal centinela tiene las siguientes desventajas sobre la búsqueda lineal:</p>

        <ul>
            <li>Añade un elemento adicional a la estructura de datos. Esto puede ser un inconveniente en algunos casos.</li>
            <li>El algoritmo puede ser ligeramente más lento que la búsqueda lineal en algunos casos. Esto se debe a que el algoritmo debe comparar el elemento actual con el centinela en cada iteración.</li>
        </ul>


        <li>Búsqueda binaria</li>

        <h1>La Búsqueda Binaria</h1>
        <p>La búsqueda binaria es un algoritmo de búsqueda eficiente que funciona con listas ordenadas. El algoritmo funciona dividiendo la lista en dos mitades, comparando el elemento buscado con el elemento en el medio de la lista. Si el elemento buscado es igual al elemento del medio, el algoritmo ha encontrado el elemento. Si el elemento buscado es menor que el elemento del medio, el algoritmo busca en la mitad inferior de la lista. Si el elemento buscado es mayor que el elemento del medio, el algoritmo busca en la mitad superior de la lista.</p>
        
        <p>El algoritmo continúa dividiendo la lista en dos mitades hasta que encuentra el elemento buscado o hasta que la lista se haya reducido a un solo elemento.</p>
        
        <p>La búsqueda binaria tiene una complejidad temporal de O(log n), donde n es el tamaño de la lista. Esto significa que el tiempo de ejecución del algoritmo es proporcional al logaritmo del tamaño de la lista.</p>
        
        <p>Aquí hay un ejemplo de código de la búsqueda binaria en JavaScript:</p>

        <img src="assets/BusquedaBinaria.png">

        <li>Búsqueda meta binaria | Búsqueda binaria unilateral</li>

        <p>La búsqueda meta binaria es un algoritmo de búsqueda que funciona de manera similar a la búsqueda binaria, pero con una diferencia clave: la búsqueda meta binaria puede comenzar en cualquier punto de la lista, en lugar de siempre comenzar en el principio.</p>

        <p>La búsqueda meta binaria funciona de la siguiente manera:</p>
        <ol>
            <li>El algoritmo comienza en el punto especificado por el usuario.</li>
            <li>El algoritmo compara el elemento en el punto actual con el elemento buscado.</li>
            <li>Si el elemento en el punto actual es igual al elemento buscado, el algoritmo devuelve el índice del punto actual.</li>
            <li>Si el elemento en el punto actual es menor que el elemento buscado, el algoritmo busca en la mitad superior de la lista.</li>
            <li>Si el elemento en el punto actual es mayor que el elemento buscado, el algoritmo busca en la mitad inferior de la lista.</li>
            <li>El algoritmo continúa dividiendo la lista en dos mitades hasta que encuentra el elemento buscado o hasta que la lista se haya reducido a un solo elemento.</li>
        </ol>
    
        <p>La búsqueda meta binaria tiene una complejidad temporal de O(log n), donde n es el tamaño de la lista. Esto significa que el tiempo de ejecución del algoritmo es proporcional al logaritmo del tamaño de la lista.</p>
    
        <p>Imagina que estás buscando un libro en una biblioteca. La biblioteca está ordenada alfabéticamente, y sabes que el libro que estás buscando está en algún lugar de la biblioteca.</p>
    
        <p>La búsqueda binaria sería como empezar a buscar en el principio de la biblioteca y seguir dividiendo la biblioteca en dos mitades hasta que encuentres el libro que estás buscando.</p>
    
        <p>La búsqueda meta binaria sería como empezar a buscar en cualquier lugar de la biblioteca que elijas. Por ejemplo, podrías empezar por el estante del medio, o por el estante más alto. Luego, seguirías dividiendo la biblioteca en dos mitades hasta que encontraras el libro que estás buscando.</p>
    
    
        <p>Aquí hay un ejemplo de código de la búsqueda meta binaria en JavaScript:</p>

        <img src="assets/busquedaMetaBinaria.png" >

        <li>Búsqueda ternaria</li>

        <p>La búsqueda ternaria es un algoritmo de búsqueda que funciona de manera similar a la búsqueda binaria, pero con una diferencia clave: la búsqueda ternaria divide la lista en tres partes en lugar de dos.</p>

        <p>La búsqueda ternaria funciona de la siguiente manera:</p>
        <ol>
            <li>El algoritmo encuentra el punto medio de la lista.</li>
            <li>El algoritmo compara el elemento en el punto medio con el elemento buscado.</li>
            <li>Si el elemento en el punto medio es igual al elemento buscado, el algoritmo devuelve el índice del punto medio.</li>
            <li>Si el elemento en el punto medio es menor que el elemento buscado, el algoritmo busca en la mitad superior de la lista.</li>
            <li>Si el elemento en el punto medio es mayor que el elemento buscado, el algoritmo busca en la mitad inferior de la lista.</li>
            <li>El algoritmo continúa dividiendo la lista en tres partes hasta que encuentra el elemento buscado o hasta que la lista se haya reducido a un solo elemento.</li>
        </ol>
    
        <p>La búsqueda ternaria tiene una complejidad temporal de O(log3 n), donde n es el tamaño de la lista. Esto significa que el tiempo de ejecución del algoritmo es proporcional al logaritmo del tamaño de la lista.</p>
    
        <p>Imagina que estás buscando un libro en una biblioteca. La biblioteca está ordenada alfabéticamente, y sabes que el libro que estás buscando está en algún lugar de la biblioteca.</p>
    
        <p>La búsqueda binaria sería como empezar a buscar en el principio de la biblioteca y seguir dividiendo la biblioteca en dos mitades hasta que encuentres el libro que estás buscando.</p>
    
        <p>La búsqueda ternaria sería como empezar a buscar en el estante del medio de la biblioteca. Luego, seguirías dividiendo la biblioteca en tres partes hasta que encontraras el libro que estás buscando.</p>
    
        <p>Aquí hay un ejemplo de código de la búsqueda ternaria en JavaScript:</p>
    
        <img src="assets/busquedaTernaria.png">

        <li>Salto de búsqueda</li>

        <p>La búsqueda de salto es un algoritmo de búsqueda que funciona de manera similar a la búsqueda binaria, pero con una diferencia clave: la búsqueda de salto utiliza un salto inicial para reducir el rango de búsqueda.</p>

        <p>La búsqueda de salto funciona de la siguiente manera:</p>
    
        <ol>
            <li>El algoritmo calcula el salto inicial, que es una función del tamaño de la lista.</li>
            <li>El algoritmo compara el elemento en la posición del salto inicial con el elemento buscado.</li>
            <li>Si el elemento en la posición del salto inicial es igual al elemento buscado, el algoritmo devuelve el índice del salto inicial.</li>
            <li>Si el elemento en la posición del salto inicial es menor que el elemento buscado, el algoritmo busca en la mitad superior de la lista.</li>
            <li>Si el elemento en la posición del salto inicial es mayor que el elemento buscado, el algoritmo busca en la mitad inferior de la lista.</li>
            <li>El algoritmo continúa dividiendo la lista en dos mitades hasta que encuentra el elemento buscado o hasta que la lista se haya reducido a un solo elemento.</li>
        </ol>
    
        <p>La búsqueda de salto tiene una complejidad temporal de O(log n / log log n), donde n es el tamaño de la lista. Esto significa que el tiempo de ejecución del algoritmo es proporcional al logaritmo del logaritmo del tamaño de la lista.</p>
    
    
        <p>Imagina que estás buscando un libro en una biblioteca. La biblioteca está ordenada alfabéticamente, y sabes que el libro que estás buscando está en algún lugar de la biblioteca.</p>
    
        <p>La búsqueda binaria sería como empezar a buscar en el principio de la biblioteca y seguir dividiendo la biblioteca en dos mitades hasta que encuentres el libro que estás buscando.</p>
    
        <p>La búsqueda de salto sería como empezar a buscar en el estante del medio de la biblioteca. Luego, seguirías dividiendo la biblioteca en dos mitades hasta que encontraras el libro que estás buscando.</p>
    
        <p>Aquí hay un ejemplo de código de la búsqueda de salto en JavaScript:</p>
    
        <img src="assets/busquedaSalto.png">

        <li>Búsqueda de interpolación</li>

        <p>La búsqueda de interpolación es un algoritmo de búsqueda que funciona de manera similar a la búsqueda binaria, pero con una diferencia clave: la búsqueda de interpolación utiliza una fórmula para estimar la posición del elemento buscado.</p>

        <p>La búsqueda de interpolación funciona de la siguiente manera:</p>
    
        <ol>
            <li>El algoritmo calcula la posición estimada del elemento buscado.</li>
            <li>El algoritmo compara el elemento en la posición estimada con el elemento buscado.</li>
            <li>Si el elemento en la posición estimada es igual al elemento buscado, el algoritmo devuelve el índice de la posición estimada.</li>
            <li>Si el elemento en la posición estimada es menor que el elemento buscado, el algoritmo busca en la mitad superior de la lista.</li>
            <li>Si el elemento en la posición estimada es mayor que el elemento buscado, el algoritmo busca en la mitad inferior de la lista.</li>
            <li>El algoritmo continúa dividiendo la lista en dos mitades hasta que encuentra el elemento buscado o hasta que la lista se haya reducido a un solo elemento.</li>
        </ol>
    
        <p>La búsqueda de interpolación tiene una complejidad temporal de O(log log n), donde n es el tamaño de la lista. Esto significa que el tiempo de ejecución del algoritmo es proporcional al logaritmo del logaritmo del tamaño de la lista.</p>
    
        <h2>Analogía</h2>
    
        <p>Imagina que estás buscando un libro en una biblioteca. La biblioteca está ordenada alfabéticamente, y sabes que el libro que estás buscando está en algún lugar de la lista.</p>
    
        <p>La búsqueda binaria sería como empezar a buscar en el principio de la biblioteca y seguir dividiendo la biblioteca en dos mitades hasta que encuentres el libro que estás buscando.</p>
    
        <p>La búsqueda de interpolación sería como empezar a buscar en el estante del medio de la biblioteca y luego seguir dividiendo la biblioteca en dos mitades, pero utilizando una fórmula para estimar la posición del libro que estás buscando.</p>
    
        <h2>Código JavaScript</h2>
    
        <p>Aquí hay un ejemplo de código de la búsqueda de interpolación en JavaScript:</p>
    
        <img src="assets/busquedaInterpolación.png">

        <li>Búsqueda exponencial</li>

        <p>La búsqueda exponencial es un algoritmo de búsqueda que funciona de manera similar a la búsqueda binaria, pero con una diferencia clave: la búsqueda exponencial utiliza un factor de salto exponencial para reducir el rango de búsqueda.</p>

        <p>La búsqueda exponencial funciona de la siguiente manera:</p>
    
        <ol>
            <li>El algoritmo calcula el factor de salto.</li>
            <li>El algoritmo compara el elemento en la posición del factor de salto con el elemento buscado.</li>
            <li>Si el elemento en la posición del factor de salto es igual al elemento buscado, el algoritmo devuelve el índice del factor de salto.</li>
            <li>Si el elemento en la posición del factor de salto es menor que el elemento buscado, el algoritmo busca en la mitad superior de la lista.</li>
            <li>Si el elemento en la posición del factor de salto es mayor que el elemento buscado, el algoritmo busca en la mitad inferior de la lista.</li>
            <li>El algoritmo continúa dividiendo la lista en dos mitades hasta que encuentra el elemento buscado o hasta que la lista se haya reducido a un solo elemento.</li>
        </ol>
    
        <p>La búsqueda exponencial tiene una complejidad temporal de O(log(log n)), donde n es el tamaño de la lista. Esto significa que el tiempo de ejecución del algoritmo es proporcional al logaritmo del logaritmo del tamaño de la lista.</p>
    
        <h2>Analogía</h2>
    
        <p>Imagina que estás buscando un libro en una biblioteca. La biblioteca está ordenada alfabéticamente, y sabes que el libro que estás buscando está en algún lugar de la lista.</p>
    
        <p>La búsqueda binaria sería como empezar a buscar en el principio de la biblioteca y seguir dividiendo la biblioteca en dos mitades hasta que encuentres el libro que estás buscando.</p>
    
        <p>La búsqueda exponencial sería como empezar a buscar en el estante del medio de la biblioteca y luego seguir dividiendo la biblioteca en dos mitades, pero utilizando un factor de salto exponencial para reducir el rango de búsqueda.</p>

        <img src="assets/busquedaExponencial.png">

        <li>Búsqueda de Fibonacci</li>

        <p>La búsqueda de Fibonacci es un algoritmo de búsqueda que funciona de manera similar a la búsqueda binaria, pero con una diferencia clave: la búsqueda de Fibonacci utiliza una secuencia de Fibonacci para reducir el rango de búsqueda.</p>

        <p>La búsqueda de Fibonacci funciona de la siguiente manera:</p>
        <ol>
            <li>El algoritmo calcula los primeros números de Fibonacci.</li>
            <li>El algoritmo compara el elemento en la posición del número de Fibonacci actual con el elemento buscado.</li>
            <li>Si el elemento en la posición del número de Fibonacci actual es igual al elemento buscado, el algoritmo devuelve el índice del número de Fibonacci actual.</li>
            <li>Si el elemento en la posición del número de Fibonacci actual es menor que el elemento buscado, el algoritmo busca en la mitad superior de la lista.</li>
            <li>Si el elemento en la posición del número de Fibonacci actual es mayor que el elemento buscado, el algoritmo busca en la mitad inferior de la lista.</li>
            <li>El algoritmo continúa dividiendo la lista en dos mitades hasta que encuentra el elemento buscado o hasta que la lista se haya reducido a un solo elemento.</li>
        </ol>
    
        <p>La búsqueda de Fibonacci tiene una complejidad temporal de O(log(log n)), donde n es el tamaño de la lista. Esto significa que el tiempo de ejecución del algoritmo es proporcional al logaritmo del logaritmo del tamaño de la lista.</p>
    
    
        <p>Imagina que estás buscando un libro en una biblioteca. La biblioteca está ordenada alfabéticamente, y sabes que el libro que estás buscando está en algún lugar de la lista.</p>
    
        <p>La búsqueda binaria sería como empezar a buscar en el principio de la biblioteca y seguir dividiendo la biblioteca en dos mitades hasta que encuentres el libro que estás buscando.</p>
    
        <p>La búsqueda de Fibonacci sería como empezar a buscar en el estante del medio de la biblioteca y luego seguir dividiendo la biblioteca en dos mitades, pero utilizando una secuencia de Fibonacci para reducir el rango de búsqueda.</p>
    
    
        <p>Aquí hay un ejemplo de código de la búsqueda de Fibonacci en JavaScript:</p>
    
        <img src="assets/busquedaFibonacci.png">

        <li>La búsqueda binaria ubicua</li>

        <p>La búsqueda binaria ubicua es una variante de la búsqueda binaria que permite encontrar el índice de un elemento en una lista ordenada, incluso si el elemento no está presente en la lista.</p>
        
        <p>La búsqueda binaria ubicua funciona de la siguiente manera:</p>

        <img src="assets/busquedaBinariaUbicua.png">

        <ul>
          <li>El algoritmo encuentra el índice del elemento más cercano al elemento buscado.</li>
          <li>Si el elemento más cercano es igual al elemento buscado, el algoritmo devuelve el índice del elemento.</li>
            <li>Si el elemento más cercano es menor que el elemento buscado, el algoritmo devuelve -1.</li>
            <li>Si el elemento más cercano es mayor que el elemento buscado, el algoritmo devuelve el índice del elemento más cercano más 1.</li>
          </ul>

        <p>La búsqueda binaria ubicua tiene una complejidad temporal de O(log n), donde n es el tamaño de la lista. Esto significa que el tiempo de ejecución del algoritmo es proporcional al logaritmo del tamaño de la lista.</p>

        <p>Imagina que estás buscando un libro en una biblioteca. La biblioteca está ordenada alfabéticamente, y sabes que el libro que estás buscando está en algún lugar de la lista.</p>

        <p>La búsqueda binaria sería como empezar a buscar en el principio de la biblioteca y seguir dividiendo la biblioteca en dos mitades hasta que encuentres el libro que estás buscando. Si no encuentras el libro, el algoritmo devuelve -1.</p>

        <p>La búsqueda binaria ubicua sería como empezar a buscar en el principio de la biblioteca y seguir dividiendo la biblioteca en dos mitades hasta que encuentres el libro más cercano al libro que estás buscando. Si el libro más cercano es igual al libro que estás buscando, el algoritmo devuelve el índice del libro. Si el libro más cercano es menor que el libro que estás buscando, el algoritmo devuelve -1. Si el libro más cercano es mayor que el libro que estás buscando, el algoritmo devuelve el índice del libro más cercano más 1.</p>

        
    </ul>

    <h2>Comparaciones</h2>

    <ul>
        <li>Búsqueda lineal vs búsqueda binaria</li>
        <li>Búsqueda de interpolación vs búsqueda binaria</li>
        <li>¿Por qué se prefiere la búsqueda binaria a la búsqueda ternaria?</li>
        <li>¿La búsqueda lineal de Sentinel es mejor que la búsqueda lineal normal?</li>
    </ul>

    <h2>Implementaciones de biblioteca de algoritmos de búsqueda</h2>

    <ul>
        <li>Funciones de búsqueda binaria en C++ STL (binary_search, lower_bound y upper_bound)</li>
        <li>Arrays.binarySearch() en Java con ejemplos | Serie 1</li>
        <li>Arrays.binarySearch() en Java con ejemplos | Conjunto 2 (Buscar en subarreglo)</li>
        <li>Collections.binarySearch() en Java con ejemplos</li>
    </ul>

    <h3>Temario</h3>

    <ul>
        <li>Encuentra los tres elementos más grandes en una matriz</li>
        <li>Encuentre el número perdido</li>
        <li>Encuentre el primer elemento repetido en una matriz de enteros</li>
        <li>Encuentra el número que falta y se repite</li>
        <li>Buscar, insertar y eliminar en una matriz ordenada</li>
        <li>Cuente 1 en una matriz binaria ordenada</li>
        <li>Dos elementos cuya suma es lo más cercano a cero</li>
        <li>Encuentra un par con la diferencia dada</li>
        <li>k elementos más grandes (o más pequeños) en una matriz</li>
        <li>K-ésimo elemento más pequeño en una matriz 2D ordenada por filas y columnas</li>
        <li>Encuentra elementos comunes en tres matrices ordenadas</li>
        <li>Techo en una matriz ordenada</li>
        <li>Piso en una matriz ordenada</li>
        <li>Encuentre el elemento máximo en una matriz que primero es creciente y luego decreciente</li>
        <li>Dada una matriz de tamaño n y un número k, encuentre todos los elementos que aparecen más de n/k veces</li>
        <li>Encuentra todos los tripletes con suma cero</li>
        <li>Encuentre el elemento antes del cual todos los elementos son más pequeños que él, y después del cual todos son más grandes</li>
        <li>Encuentre la suma de pares más grande en una matriz no ordenada</li>
        <li>K'th elemento más pequeño/más grande en matriz no ordenada</li>
        <li>Buscar un elemento en una matriz ordenada y rotada</li>
        <li>Encuentre el elemento mínimo en una matriz ordenada y rotada</li>
        <li>Encuentra un elemento pico</li>
        <li>Máximo y mínimo de una matriz usando el número mínimo de comparaciones</li>
        <li>Encuentra un punto fijo en una matriz dada</li>
        <li>Encuentra las k palabras más frecuentes de un archivo</li>
        <li>Encuentra los k elementos más cercanos a un valor dado</li>
        <li>Dada una matriz ordenada y un número x, encuentre el par en la matriz cuya suma es más cercana a x</li>
        <li>Encuentre el par más cercano de dos matrices ordenadas</li>
        <li>Encuentre tres elementos más cercanos de tres matrices ordenadas dadas</li>
        <li>Búsqueda binaria de números racionales sin usar aritmética de punto flotante</li>
        <li>Mediana de dos matrices ordenadas</li>
        <li>Mediana de dos arreglos ordenados de diferentes tamaños</li>
        <li>Buscar en una matriz casi ordenada</li>
        <li>Encuentra la posición de un elemento en una matriz ordenada de números infinitos</li>
        <li>Dada una matriz ordenada y rotada, encuentre si hay un par con una suma dada</li>
        <li>K'th elemento más pequeño/más grande en matriz no ordenada | Tiempo lineal en el peor de los casos</li>
        <li>K'th elemento más grande en una corriente</li>
        <li>Mejor primera búsqueda (búsqueda informada)</li>
      </ul>

      
      <nav class="Nav">
        
      <section id="menu1">
        <a href="#menu1" class="submenu">Conceptos Básicos JS</a>
        <div class="submenu-content">
          <a href="IntroduccionJs.html">Introducción a JavaScript</a>
          <a href="TiposDeDatos.html">Tipos de Datos</a>
          <a href="EstructurasdeControl.html">Estructuras de Control</a>
          <a href="ProgramaciónOrientadaaObjetos.html">Programación Orientada a Objetos</a>
          <a href="ObjetosyFuncionesDeLenguaje.html">Objetos y Funciones del Lenguaje</a>
          <a href="ProgrmacionAsincrona.html">Programación Asíncrona</a>
          <a href="NuevosTiposYCaracteristicas.html">Nuevos Tipos y Características</a>
          <a href="this.html">this en JavaScript</a>
          <a href="JSON.html">JSON: JavaScript Object Notation</a>
          <a href="DOM.html">DOM: Document Object Model</a>
          <a href="AJAX.html">AJAX: Asynchronous JavaScript And XML</a>
          <a href="ApiRest.html">APIs REST</a>
      </section>
    
      <section id="menu2">
        <a href="#menu2" class="submenu">Estructuras de datos</a>
        <div class="submenu-content">
          <a href="Arrays.html">Arrays</a>
          <a href="LinkedList.html">Lista enlazada</a>
          <a href="Stack.html">Pila</a>
          <a href="Queve.html">Cola</a>
          <a href="BinaryTree.html">Árbol binario</a>
          <a href="BinarySearchTree.html">Árbol de búsqueda binario</a>
          <a href="Heap.html">Montículo</a>
          <a href="Hashing.html">Hashing</a>
          <a href="Graph.html">Grafo</a>
          <a href="Matriz.html">Matriz</a>
        </div>
      </section>

        
      <section id="menu3">
          <a href="#menu3" class="submenu">Análisis de algoritmos</a>
          <div class="submenu-content">
              <a href="SearchingAlgorithms.html">Búsqueda y ordenamiento</a>
              <a href="GreedyAlgorithms.html">Algoritmos codiciosos</a>
              <a href="DynamicProgramming.html">Programación dinámica</a>
              <a href="PatternSearching.html">Búsqueda de patrones</a>
              <a href="Backtracking.html">Algoritmos de Retroceso</a>
              <a href="DivideAndConquer.html">Divide y conquista</a>
              <a href="GeometricAlgorithms.html">Algoritmos geométricos</a>
              <a href="MathematicalAlgorithms.html">Algoritmos matemáticos</a>
              <a href="BitwiseAlgorithms.html">Algoritmos de bits</a>
          </div>
      </section>

      <section id="menu4">
        <a href="#menu4" class="submenu">Ejercicios Logicos y pracicos</a>
      <div class="submenu-content">
            <a href="OperadoresString.html">Operadores string</a>
            <a href="EjerciciosArrays.html">Ejercicios Arrays</a>
            <a href="EjerciciosTemplateString.html">Ejercicios Template String</a>
            <a href="EjercicosObjetos.html">Ejercicios Objetos</a>
            <a href="EjerciciosFunciones.html">Ejercicios Funciones</a>
            <a href="EjerciciosAritmeticos.html">Ejercicios Aritmeticos</a>
            <a href="OperadoresDeAsignacion.html">Operadores De Asignacion</a>
            <a href="OperadoresDeComparacion.html">Operadores De Comparacion</a>
            <a href="OperadoresLogicos.html">Operadores Logicos</a>
            <a href="OperadoresTernarios.html">Operadores Ternarios</a>
            <a href="OperadoresDeTipo.html">Operadores de Tipo</a>
            <a href="CondicionalIf.html">Condicional If</a>
            <a href="CondicionalIfElse.html">Codicional If Else</a>
            <a href="CicloFor.html">Ciclo For</a>
            <a href="CicloWhile.html">Ciclo While</a>
            <a href="CicloDoWhile.html">Ciclo Do While</a>
            <a href="CicloSwitch.html">Ciclo Switch</a>
            <a href="EjerciciosPOO.html">Ejercicios de Progrmacion Orientada A Objetos</a>
            <a href="EjerciciosDOM.html">EjerciciosDOM</a>
            <a href="EjerciciosAJAX.html">EjerciciosAJAX</a>
        </div>
    </section> 

    <section id="menu5">
        <a href="#menu5" class="submenu">Ejercicios Practicos Con Orientación y Componentes</a>
      <div class="submenu-content">
        <a href="PracticasAJAX.html">Practicas AJAX</a>
        <a href="PracticasDOM.html">Practicas DOM</a>
      </div>
    </section> 


    <section id="menu6">
      <a href="#menu6" class="submenu">Seguridad informática</a>
      <div class="submenu-content">
        <a href="FundamentosDeLaSeguridadInformatica.html">Fundamentos de la Seguridad Informática</a>
        <a href="SeguridadDeLosSistemasOperativos.html">Seguridad de los Sistemas Operativos</a>
        <a href="SeguridadDeLasRedes.html">Seguridad de las Redes</a>
        <a href="SeguridadDeLasAplicaciones.html">Seguridad de las Aplicaciones</a>
        <a href="SeguridadDeLosDatos.html">Seguridad de los Datos</a>
        <a href="SeguridadDeLaNube.html">Seguridad de la Nube</a>
        <a href="SeguridadDeLosSistemasEmbebidos.html">Seguridad de los Sistemas Embebidos</a>
        <a href="SeguridadDeLaAuditoria.html">Seguridad de la Auditoría</a>
        <a href="SeguridadDeLaGestionDeIncidentes.html">Seguridad de la Gestión de Incidentes</a>
        <a href="SeguridadDeLaEtica.html">Seguridad de la Ética</a>
        <a href="SeguridadDeLaLegislacion.html">Seguridad de la Legislación</a>
      </div>
    </section>
    

    <section id="menu7">
      <a href="#menu7" class="submenu">Arquitectura de las computadoras</a>
      <div class="submenu-content">
        <a href="IntroduccionArquitecturaComputadoras.html">Introducción a la Arquitectura de Computadoras</a>
        <a href="ComponentesFundamentales.html">Componentes Fundamentales</a>
        <a href="ArquitecturaCPU.html">Arquitectura de CPU</a>
        <a href="MemoriaAlmacenamiento.html">Memoria y Almacenamiento</a>
        <a href="SistemaGrafico.html">Sistema Grafico</a>
        <a href="SistemasEntradaSalida.html">Sistemas de Entrada/Salida (E/S)</a>
        <a href="BusesConexiones.html">Buses y Conexiones</a>
        <a href="OrganizacionDatos.html">Organización de Datos</a>
        <a href="ArquitecturasComputadorasModernas.html">Arquitecturas de Computadoras Modernas</a>
        <a href="Microprocesadores.html">Microprocesadores</a>
        <a href="SistemasMultiprocesador.html">Sistemas Multiprocesador</a>
        <a href="MemoriaCache.html">Memoria Caché</a>
        <a href="ArquitecturaRedesComputadoras.html">Arquitectura de Redes y Computadoras</a>
        <a href="ArquitecturaComputadorasCuanticas.html">Arquitectura de Computadoras Cuánticas</a>
        <a href="TendenciasFuturasArquitecturaComputadoras.html">Tendencias Futuras en Arquitectura de Computadoras</a>
        
      </div>
    </section>

    <section id="menu8">
      <a href="#menu8" class="submenu">Sistemas Operativos</a>
      <div class="submenu-content">
        <a href="introduccionASistemasOperativos.html">Introducción a los Sistemas Operativos</a>
        <a href="tiposDeSistemasOperativos.html">Tipos de Sistemas Operativos</a>
        <a href="interfazDeUsuario.html">Interfaz de Usuario</a>
        <a href="gestionDeArchivosYDirectorios.html">Gestión de Archivos y Directorios</a>
        <a href="procesosYTareas.html">Procesos y Tareas</a>
        <a href="gestionDeMemoria.html">Gestión de Memoria</a>
        <a href="sistemasDeArchivos.html">Sistemas de Archivos</a>
        <a href="seguridadYControlDeAcceso.html">Seguridad y Control de Acceso</a>
        <a href="redesYComunicaciones.html">Redes y Comunicaciones</a>
        <a href="administracionDelSistema.html">Administración del Sistema</a>
        <a href="virtualizacionYContenedores.html">Virtualización y Contenedores</a>
        <a href="sistemasDeArchivosAvanzados.html">Sistemas de Archivos Avanzados</a>
        <a href="rendimientoYOptimizacion.html">Rendimiento y Optimización</a>
        <a href="sistemasOperativosEspeciales.html">Sistemas Operativos Especiales</a>
        <a href="tendenciasActuales.html">Tendencias Actuales</a>
      </div>
    </section>
    
    <section id="menu9">
      <a href="#menu9" class="submenu">Arquitectura de Redes</a>
      <div class="submenu-content">
        <a href="IntroduccionArquitecturaRedes.html">Introducción a la Arquitectura de Redes</a>
        <a href="TopologiasRed.html">Topologías de Red</a>
        <a href="ModeloOSI.html">Modelo OSI (Open Systems Interconnection)</a>
        <a href="ProtocoloInternet.html">Protocolo de Internet (IP)</a>
        <a href="ProtocolosTransporte.html">Protocolos de Transporte (TCP/UDP)</a>
        <a href="RedesLocales.html">Redes Locales (LAN)</a>
        <a href="RedesAreaExtensa.html">Redes de Área Extensa (WAN)</a>
        <a href="ArquitecturaClienteServidor.html">Arquitectura Cliente-Servidor</a>
        <a href="RedesInalambricas.html">Redes Inalámbricas (Wi-Fi)</a>
        <a href="RedesDefinidasSoftware.html">Redes Definidas por Software (SDN)</a>
        <a href="RedesAreaAmpliaDefinidasSoftware.html">Redes de Área Amplia Definidas por Software (SD-WAN)</a>
        <a href="SeguridadRed.html">Seguridad de Red</a>
        <a href="ArquitecturaRedesNube.html">Arquitectura de Redes para la Nube</a>
        <a href="Redes5GFuturasTecnologias.html">Redes 5G y Futuras Tecnologías</a>
      </div>
    </section>


    <section id="menu10">
      <a href="#menu10" class="submenu">Bases De Datos</a>
      <div class="submenu-content">
        <a href="introduccionALasBasesDeDatos.html">Introducción a las Bases de Datos</a>
        <a href="modelosDeDatos.html">Modelos de Datos</a>
        <a href="sistemasDeGestionDeBasesDeDatos.html">Sistemas de Gestión de Bases de Datos (DBMS)</a>
        <a href="disenoDeBasesDeDatosRelacionales.html">Diseño de Bases de Datos Relacionales</a>
        <a href="sqlYConsultasABasesDeDatos.html">SQL y Consultas a Bases de Datos</a>
        <a href="normalizacionDeBasesDeDatos.html">Normalización de Bases de Datos</a>
        <a href="indicesYOptimizacionDeConsultas.html">Índices y Optimización de Consultas</a>
        <a href="transaccionesYControlDeConcurrencia.html">Transacciones y Control de Concurrencia</a>
        <a href="seguridadYPrivacidadDeDatos.html">Seguridad y Privacidad de Datos</a>
        <a href="basesDeDatosNoRelacionalesNoSQL.html">Bases de Datos No Relacionales (NoSQL)</a>
        <a href="basesDeDatosDistribuidas.html">Bases de Datos Distribuidas</a>
        <a href="almacenamientoYCopiaDeSeguridadBackup.html">Almacenamiento y Copia de Seguridad (Backup)</a>
        <a href="integracionDeBasesDeDatosEnAplicaciones.html">Integración de Bases de Datos en Aplicaciones</a>
        <a href="tendenciasFuturasEnBasesDeDatos.html">Tendencias Futuras en Bases de Datos</a>
      </div>
    </section>

    <section id="menu11">
      <a href="#menu11" class="submenu">Lenguajes de Programación</a>
      <div class="submenu-content">
        <a href="fundamentos.html">Fundamentos de Programación y Sintaxis</a><br>
        <a href="tipos_datos.html">Tipos de Datos y Variables</a><br>
        <a href="estructuras_control.html">Estructuras de Control</a><br>
        <a href="funciones.html">Funciones y Procedimientos</a><br>
        <a href="estructuras_datos.html">Estructuras de Datos Básicas</a><br>
        <a href="poo_intro.html">Introducción a la Programación Orientada a Objetos (POO)</a><br>
        <a href="encapsulamiento.html">Encapsulamiento y Modificadores de Acceso</a><br>
        <a href="herencia_polimorfismo.html">Herencia y Polimorfismo</a><br>
        <a href="abstraccion_interfaces.html">Abstracción y Interfaces</a><br>
        <a href="excepciones.html">Excepciones y Manejo de Errores</a><br>
        <a href="hilos_concurrencia.html">Hilos y Concurrencia</a><br>
        <a href="programacion_funcional.html">Programación Funcional</a><br>
        <a href="gestion_memoria.html">Gestión de Memoria y Rendimiento</a><br>
        <a href="diseno_lenguajes.html">Diseño de Lenguajes de Programación</a><br>
        <a href="compiladores_interpretes.html">Compiladores e Intérpretes</a><br>
        <a href="paradigmas_avanzados.html">Paradigmas de Programación Avanzados</a><br>
        <a href="seguridad_criptografia.html">Seguridad y Criptografía en Lenguajes</a><br>
        <a href="tendencias.html">Futuras Tendencias en Lenguajes de Programación</a><br>
      </div>
    </section>
    

     </nav>

    </main>



    <footer>
        <nav class="navegation">
            <a href="AnalisisDeALgoritmos.html"><i class="fa-solid fa-arrow-left"></i></a>
            <a href="GreedyAlgorithms.html"><i class="fa-solid fa-arrow-right"></i></a>
            <a href="Index.html"><i class="fa-solid fa-house"></i></a>
            <a class="toogleMenu" id="toogleMenu" href="#"><i class="fa-solid fa-bars"></i></a>
 
        </nav>
    </footer>
    
    
    <script src="js/Script.js"></script>
    <script src="js/AnalisisAlgoritmico.js"></script>


</body>
</html>